---
/**
 * PASSIVE TREE EDITOR (Admin Tool)
 *
 * Hidden admin tool for visually allocating passive tree nodes per build progression.
 * Based on V2 viewer rendering with added interactivity (click-to-allocate).
 * Password-protected with SHA-256 hash comparison + localStorage caching.
 *
 * Route: /admin/tree-editor/ (not linked in navigation)
 */
import BaseLayout from '../../layouts/BaseLayout.astro';
import Navigation from '../../components/Navigation.astro';
import skillsRaw from '../../data/skills.json';
const skillsJsonStr = JSON.stringify(skillsRaw);
---

<BaseLayout title="Tree Editor">
  <Navigation slot="header" />
  <script is:inline define:vars={{ skillsJsonStr }}>
    window.__SKILLS_DATA__ = JSON.parse(skillsJsonStr);
  </script>

  <!-- Password Gate -->
  <div class="te-auth-gate" id="te-auth-gate">
    <div class="te-auth-box">
      <h2 class="te-auth-title">Admin Access</h2>
      <p class="te-auth-desc">Enter the admin password to access the tree editor.</p>
      <div class="te-auth-field">
        <input type="password" id="te-auth-input" class="te-auth-input" placeholder="Password" autocomplete="off" />
        <button class="te-auth-btn" id="te-auth-btn">Unlock</button>
      </div>
      <p class="te-auth-error" id="te-auth-error"></p>
    </div>
  </div>

  <!-- Editor (hidden until auth) -->
  <section class="te-page" id="te-editor" style="display:none">
    <div class="te-layout">
      <!-- Sidebar -->
      <div class="te-sidebar">
        <div class="te-sidebar-section">
          <label class="te-label">Class</label>
          <select id="te-class-select" class="te-select"></select>
        </div>
        <div class="te-sidebar-section">
          <label class="te-label">Ascendancy</label>
          <select id="te-asc-select" class="te-select">
            <option value="">(None)</option>
          </select>
        </div>

        <div class="te-divider"></div>

        <div class="te-sidebar-section">
          <label class="te-label">Loadout</label>
          <select id="te-loadout-select" class="te-select"></select>
        </div>
        <div class="te-sidebar-section">
          <label class="te-label">Progression</label>
          <select id="te-progression-select" class="te-select"></select>
        </div>

        <div class="te-divider"></div>

        <div class="te-sidebar-section">
          <label class="te-label">Points</label>
          <div class="te-counters">
            <div class="te-counter">
              <span class="te-counter-label">Main</span>
              <span class="te-counter-value" id="te-main-points">0 / 123</span>
            </div>
            <div class="te-counter">
              <span class="te-counter-label">Ascendancy</span>
              <span class="te-counter-value" id="te-asc-points">0 / 8</span>
            </div>
          </div>
        </div>

        <div class="te-divider"></div>

        <div class="te-sidebar-section te-actions">
          <button class="te-action-btn te-btn-primary" id="te-load-btn">Load from Progression</button>
          <button class="te-action-btn te-btn-accent" id="te-copy-btn">Copy treeData JSON</button>
          <button class="te-action-btn" id="te-download-btn">Download skills.json</button>
          <button class="te-action-btn te-btn-danger" id="te-reset-btn">Reset All Nodes</button>
        </div>

        <div class="te-divider"></div>

        <div class="te-sidebar-section">
          <label class="te-label">Info</label>
          <p class="te-info" id="te-info">Click nodes to allocate/deallocate. Use sidebar to load/save.</p>
        </div>
      </div>

      <!-- Canvas Area -->
      <div class="te-canvas-area">
        <div class="te-header">
          <span class="te-title">Passive Tree Editor</span>
          <div class="te-controls">
            <span class="te-zoom-label">Zoom: <span id="te-zoom-value">100%</span></span>
            <button class="te-btn" id="te-view-reset-btn" title="Reset View">&#x27F2;</button>
          </div>
        </div>

        <div class="te-viewer" id="te-viewer">
          <canvas id="te-canvas"></canvas>
          <div class="te-loading" id="te-loading">
            <div class="te-spinner"></div>
            <span id="te-loading-text">Loading passive tree...</span>
          </div>

          <!-- Node Tooltip (hover) -->
          <div class="te-node-tooltip" id="te-node-tooltip" style="display:none">
            <div class="te-header-bar">
              <img class="te-header-img-left" id="te-tooltip-header-left" src="" alt="">
              <div class="te-header-mid" id="te-tooltip-header-mid">
                <span class="te-header-name" id="te-tooltip-name"></span>
              </div>
              <img class="te-header-img-right" id="te-tooltip-header-right" src="" alt="">
            </div>
            <div class="te-tooltip-body" id="te-tooltip-body"></div>
          </div>

          <!-- Mastery Popup (click) -->
          <div class="te-mastery-popup" id="te-mastery-popup" style="display:none">
            <div class="te-header-bar">
              <img class="te-header-img-left" id="te-popup-header-left" src="" alt="">
              <div class="te-header-mid" id="te-popup-header-mid">
                <span class="te-header-name" id="te-mastery-popup-title">Select Mastery Effect</span>
              </div>
              <img class="te-header-img-right" id="te-popup-header-right" src="" alt="">
              <button class="te-mastery-popup-close" id="te-mastery-popup-close">&times;</button>
            </div>
            <div class="te-mastery-popup-effects" id="te-mastery-popup-effects"></div>
            <button class="te-mastery-popup-clear" id="te-mastery-popup-clear" style="display:none">Remove Mastery</button>
          </div>
        </div>

        <div class="te-footer">
          <span class="te-stat" id="te-stat-nodes">Nodes: 0</span>
          <span class="te-stat" id="te-stat-groups">Groups: 0</span>
          <span class="te-stat" id="te-stat-allocated">Allocated: 0</span>
        </div>
      </div>
    </div>
  </section>
</BaseLayout>

<style is:global>
  /* Auth Gate */
  .te-auth-gate {
    min-height: calc(100vh - 60px);
    display: flex;
    align-items: center;
    justify-content: center;
    background: #0a0a0f;
  }
  .te-auth-gate.hidden { display: none; }
  .te-auth-box {
    background: #0d0d14;
    border: 1px solid #1a1a25;
    border-radius: 8px;
    padding: 2rem;
    max-width: 380px;
    width: 100%;
    text-align: center;
  }
  .te-auth-title {
    color: #c8b07a;
    font-size: 1.2rem;
    margin: 0 0 0.5rem;
  }
  .te-auth-desc {
    color: #606070;
    font-size: 0.85rem;
    margin: 0 0 1.5rem;
  }
  .te-auth-field {
    display: flex;
    gap: 0.5rem;
  }
  .te-auth-input {
    flex: 1;
    padding: 0.6rem 0.8rem;
    background: #101018;
    border: 1px solid #2a2a35;
    border-radius: 4px;
    color: #e0e0e0;
    font-size: 0.9rem;
    outline: none;
  }
  .te-auth-input:focus { border-color: #c8b07a; }
  .te-auth-btn {
    padding: 0.6rem 1.2rem;
    background: #c8b07a;
    border: none;
    border-radius: 4px;
    color: #0a0a0f;
    font-weight: 600;
    font-size: 0.9rem;
    cursor: pointer;
    transition: opacity 0.2s;
  }
  .te-auth-btn:hover { opacity: 0.85; }
  .te-auth-error {
    color: #e04040;
    font-size: 0.8rem;
    margin: 0.75rem 0 0;
    min-height: 1.2em;
  }

  /* Editor Layout */
  .te-page {
    min-height: calc(100vh - 60px);
    background: #0a0a0f;
  }
  .te-layout {
    display: flex;
    height: calc(100vh - 60px);
  }

  /* Sidebar */
  .te-sidebar {
    width: 280px;
    min-width: 280px;
    background: #0d0d14;
    border-right: 1px solid #1a1a25;
    padding: 1rem;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
  }
  .te-sidebar-section {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }
  .te-label {
    font-size: 0.7rem;
    font-weight: 600;
    color: #606070;
    text-transform: uppercase;
    letter-spacing: 0.08em;
  }
  .te-select {
    padding: 0.5rem 0.6rem;
    background: #101018;
    border: 1px solid #2a2a35;
    border-radius: 4px;
    color: #e0e0e0;
    font-size: 0.85rem;
    outline: none;
    cursor: pointer;
  }
  .te-select:focus { border-color: #c8b07a; }
  .te-divider {
    height: 1px;
    background: #1a1a25;
    margin: 0.5rem 0;
  }
  .te-counters {
    display: flex;
    flex-direction: column;
    gap: 0.4rem;
  }
  .te-counter {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.4rem 0.6rem;
    background: #101018;
    border-radius: 4px;
  }
  .te-counter-label {
    font-size: 0.8rem;
    color: #808090;
  }
  .te-counter-value {
    font-size: 0.85rem;
    font-weight: 600;
    color: #c8b07a;
  }
  .te-actions {
    gap: 0.4rem;
  }
  .te-action-btn {
    padding: 0.55rem 0.8rem;
    background: #1a1a24;
    border: 1px solid #2a2a35;
    border-radius: 4px;
    color: #a0a0b0;
    font-size: 0.8rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    text-align: center;
  }
  .te-action-btn:hover { background: #252530; color: #e0e0e0; }
  .te-btn-primary { border-color: #3a5a8a; color: #6a9fd8; }
  .te-btn-primary:hover { background: #1a2a40; color: #8ab8e8; }
  .te-btn-accent { border-color: #5a4a2a; color: #c8b07a; }
  .te-btn-accent:hover { background: #2a2418; color: #d8c08a; }
  .te-btn-danger { border-color: #5a2a2a; color: #d06060; }
  .te-btn-danger:hover { background: #2a1818; color: #e07070; }
  .te-info {
    font-size: 0.75rem;
    color: #505060;
    margin: 0;
    line-height: 1.5;
  }

  /* Canvas Area */
  .te-canvas-area {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-width: 0;
  }
  .te-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0.75rem 1rem;
    background: #101018;
    border-bottom: 1px solid #1a1a25;
  }
  .te-title {
    font-size: 0.9rem;
    font-weight: 600;
    color: #c8b07a;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }
  .te-controls {
    display: flex;
    align-items: center;
    gap: 0.75rem;
  }
  .te-zoom-label {
    font-size: 0.75rem;
    color: #606070;
  }
  .te-btn {
    background: #1a1a24;
    border: 1px solid #2a2a35;
    border-radius: 4px;
    padding: 0.4rem 0.6rem;
    color: #808090;
    cursor: pointer;
    font-size: 0.85rem;
    transition: all 0.2s ease;
  }
  .te-btn:hover { background: #252530; color: #c8b07a; }
  .te-viewer {
    position: relative;
    flex: 1;
    background: #05050a;
    cursor: grab;
  }
  .te-viewer:active { cursor: grabbing; }
  #te-canvas {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
  }
  .te-loading {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 1rem;
    background: rgba(5, 5, 10, 0.9);
    color: #606070;
    font-size: 0.9rem;
  }
  .te-loading.hidden { display: none; }
  .te-spinner {
    width: 32px;
    height: 32px;
    border: 3px solid #1a1a25;
    border-top-color: #c8b07a;
    border-radius: 50%;
    animation: te-spin 1s linear infinite;
  }
  @keyframes te-spin { to { transform: rotate(360deg); } }
  .te-footer {
    display: flex;
    align-items: center;
    gap: 1.5rem;
    padding: 0.6rem 1rem;
    background: #101018;
    border-top: 1px solid #1a1a25;
  }
  .te-stat {
    font-size: 0.75rem;
    color: #606070;
  }

  /* ========================================
     SHARED: Tooltip (hover) + Popup (click)
     ======================================== */
  .te-node-tooltip,
  .te-mastery-popup {
    position: absolute;
    background: rgba(0, 0, 0, 0.95);
    border: none;
    border-radius: 0;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.8);
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    font-size: 1.05rem;
  }
  .te-node-tooltip {
    z-index: 15;
    min-width: 340px;
    max-width: 500px;
    pointer-events: none;
  }
  .te-mastery-popup {
    z-index: 10;
    min-width: 380px;
    max-width: 540px;
    max-height: 480px;
    overflow-y: auto;
  }

  /* Header bar (shared by both) */
  .te-header-bar {
    display: flex;
    align-items: center;
    height: 44px;
    position: relative;
  }
  .te-header-img-left,
  .te-header-img-right {
    height: 44px;
    width: auto;
    display: block;
    flex-shrink: 0;
  }
  .te-header-mid {
    flex: 1;
    height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
    background-size: auto 44px;
    background-repeat: repeat-x;
    background-position: center center;
    padding: 0 8px;
    overflow: hidden;
  }
  .te-header-name {
    font-size: 1.1rem;
    font-weight: 600;
    color: #ffffff;
    text-shadow: 0 1px 4px rgba(0, 0, 0, 0.9);
    letter-spacing: 0.3px;
    white-space: nowrap;
  }

  /* Close button (popup only) */
  .te-mastery-popup-close {
    position: absolute;
    right: 2px;
    top: 2px;
    background: none;
    border: none;
    color: #808090;
    font-size: 1.2rem;
    cursor: pointer;
    padding: 0 0.3rem;
    z-index: 1;
  }
  .te-mastery-popup-close:hover { color: #e0e0e0; }

  /* Body (shared) */
  .te-tooltip-body {
    padding: 12px 14px;
  }
  .te-tooltip-stat {
    font-size: 1.05rem;
    line-height: 1.5;
    color: #8888ff;
    margin-bottom: 3px;
  }
  .te-tooltip-reminder {
    font-size: 0.9rem;
    line-height: 1.3;
    color: #808080;
    font-style: italic;
    margin-top: 4px;
  }
  .te-tooltip-separator {
    border: none;
    margin: 0;
    height: 0;
  }
  .te-tooltip-mastery-label {
    font-size: 0.9rem;
    color: #606070;
    margin-bottom: 4px;
  }

  /* Mastery effect row: bullet + text */
  .te-tooltip-mastery-effect {
    display: flex;
    align-items: flex-start;
    gap: 6px;
    margin-bottom: 2px;
  }
  .te-tooltip-mastery-effect img {
    width: 16px;
    height: 16px;
    flex-shrink: 0;
    margin-top: 2px;
    opacity: 0.7;
  }
  .te-mastery-effect-option img {
    width: 18px;
    height: 18px;
    flex-shrink: 0;
    margin-top: 2px;
    opacity: 0.7;
  }
  .te-tooltip-mastery-effect-text {
    font-size: 1.05rem;
    line-height: 1.5;
    color: #8888ff;
  }

  /* Popup effect options */
  .te-mastery-popup-effects {
    display: flex;
    flex-direction: column;
    gap: 0.15rem;
    padding: 10px 12px;
  }
  .te-mastery-effect-option {
    display: flex;
    align-items: flex-start;
    gap: 7px;
    padding: 0.4rem 0.5rem;
    background: transparent;
    border: 1px solid transparent;
    border-radius: 2px;
    color: #8888ff;
    font-size: 1.05rem;
    font-family: inherit;
    cursor: pointer;
    text-align: left;
    transition: all 0.15s;
    line-height: 1.5;
  }
  .te-mastery-effect-option:hover {
    background: rgba(136, 136, 255, 0.08);
    border-color: rgba(136, 136, 255, 0.25);
    color: #aaaaff;
  }
  .te-mastery-effect-option.selected {
    background: rgba(74, 138, 58, 0.1);
    border-color: rgba(74, 138, 58, 0.3);
    color: #8ad07a;
  }
  .te-mastery-popup-clear {
    margin: 4px 10px 8px;
    padding: 0.4rem 0.6rem;
    background: rgba(208, 96, 96, 0.08);
    border: 1px solid rgba(208, 96, 96, 0.2);
    border-radius: 2px;
    color: #d06060;
    font-size: 0.75rem;
    font-family: inherit;
    cursor: pointer;
    width: calc(100% - 20px);
  }
  .te-mastery-popup-clear:hover { background: rgba(208, 96, 96, 0.15); }
</style>

<script>
  /**
   * PASSIVE TREE EDITOR
   *
   * Based on V2 viewer with added:
   * - Node allocation state (click to toggle)
   * - Active/inactive sprite rendering
   * - Sidebar with loadout/progression picker
   * - Save/load treeData JSON
   */
  (function() {
    'use strict';

    const BASE_URL = import.meta.env.BASE_URL || '/';

    // ==========================================
    // AUTH
    // ==========================================
    const PASS_HASH = '65d105253d80116c311f238340feb30076e40f02c9cf7ada10cb7c8afa0bbed4'; // sha256("emiracle-admin")
    const AUTH_KEY = 'te-auth-token';

    const authGate = document.getElementById('te-auth-gate');
    const authInput = document.getElementById('te-auth-input') as HTMLInputElement;
    const authBtn = document.getElementById('te-auth-btn');
    const authError = document.getElementById('te-auth-error');
    const editorEl = document.getElementById('te-editor');

    async function sha256(text: string): Promise<string> {
      const buf = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(text));
      return Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2, '0')).join('');
    }

    async function tryAuth(password: string): Promise<boolean> {
      const hash = await sha256(password);
      return hash === PASS_HASH;
    }

    function unlock() {
      authGate?.classList.add('hidden');
      if (editorEl) editorEl.style.display = '';
      localStorage.setItem(AUTH_KEY, 'true');
      initEditor();
    }

    // ==========================================
    // TYPES
    // ==========================================
    interface SpriteCoord {
      x: number; y: number; w: number; h: number;
    }
    interface SpriteCategory {
      filename: string;
      w: number;
      h: number;
      coords: Record<string, SpriteCoord>;
    }
    interface SpritesData {
      sprites: Record<string, SpriteCategory>;
      extraImages?: any[];
    }
    interface TreeNode {
      skill?: number;
      name?: string;
      icon?: string;
      stats?: string[];
      reminderText?: string[];
      group: number;
      orbit: number;
      orbitIndex: number;
      out?: string[];
      in?: string[];
      isNotable?: boolean;
      isKeystone?: boolean;
      isMastery?: boolean;
      isJewelSocket?: boolean;
      expansionJewel?: { size: number; index: number; proxy: string; parent?: string };
      isBloodline?: boolean;
      isMultipleChoiceOption?: boolean;
      ascendancyName?: string;
      isAscendancyStart?: boolean;
      classStartIndex?: number;
      inactiveIcon?: string;
      activeIcon?: string;
      activeEffectImage?: string;
      masteryEffects?: { effect: number; stats: string[] }[];
    }
    interface TreeGroup {
      x: number;
      y: number;
      orbits: number[];
      nodes: string[];
      background?: { image: string; isHalfImage?: boolean };
      isProxy?: boolean;
    }
    interface TreeData {
      nodes: Record<string, TreeNode>;
      groups: Record<string, TreeGroup>;
      constants: {
        orbitRadii: number[];
        skillsPerOrbit: number[];
        PSSCentreInnerRadius: number;
      };
      min_x: number; min_y: number;
      max_x: number; max_y: number;
      classes: any[];
    }
    interface SkillsLoadout {
      name: string;
      description?: string;
      defaultProgression: string;
      progressions: Record<string, {
        name: string;
        passiveTree: { plannerUrl: string; treeData: string };
        [key: string]: any;
      }>;
    }
    interface SkillsJson {
      version: string;
      loadouts: Record<string, SkillsLoadout>;
    }

    // ==========================================
    // EDITOR STATE
    // ==========================================
    let treeData: TreeData | null = null;
    let spritesData: SpritesData | null = null;
    let skillsData: SkillsJson | null = null;
    const atlases: Record<string, HTMLImageElement> = {};
    const nodePositions = new Map<string, { x: number; y: number; node: TreeNode }>();
    const ascendancyGroups = new Map<string, string>();
    const ascStartGroups = new Map<string, string>();
    const classStartGroups = new Map<string, string>();
    const lineOnlyGroups = new Set<string>([]);

    // Class name -> background atlas key
    const classToBackground: Record<string, string> = {
      'Marauder': 'BackgroundStr',
      'Ranger': 'BackgroundDex',
      'Witch': 'BackgroundInt',
      'Duelist': 'BackgroundStrDex',
      'Templar': 'BackgroundStrInt',
      'Shadow': 'BackgroundDexInt',
    };

    // Allocation state
    const allocatedNodes = new Set<string>();

    // Hover preview state
    let hoveredNodeId: string | null = null;
    let hoverPreviewPath: string[] = [];   // full BFS path for green allocation preview
    let hoverOrphans = new Set<string>();  // red nodes for cascade deallocation preview
    let hoverRafId = 0;

    // Mastery state: nodeId -> selected effect ID
    const allocatedMasteries = new Map<string, number>();
    let activeMasteryNodeId: string | null = null;
    let pendingMasteryPath: string[] = [];  // nodes to allocate when mastery effect is chosen

    // Adjacency graph: nodeId -> Set of connected nodeIds (bidirectional, skipping classStart/mastery)
    const adjacency = new Map<string, Set<string>>();

    // Class/ascendancy state
    let selectedClass = '';       // e.g. "Marauder"
    let selectedAscendancy = '';  // e.g. "Chieftain" or "" for none
    let classStartNodeId = '';    // the classStartIndex center node for selected class
    // Map: className (from treeData.classes) -> classStartIndex nodeId
    const classToStartNode = new Map<string, string>();
    // Map: className -> list of ascendancy names
    const classAscendancies = new Map<string, string[]>();

    // View state
    let panX = 0;
    let panY = 0;
    let zoom = 0.05;
    let isPanning = false;
    let panStartX = 0;
    let panStartY = 0;

    // Currently selected loadout/progression
    let currentLoadout = '';
    let currentProgression = '';

    // DOM refs (editor)
    let viewer: HTMLElement | null = null;
    let canvas: HTMLCanvasElement | null = null;
    let ctx: CanvasRenderingContext2D | null = null;
    let loadingEl: HTMLElement | null = null;
    let loadingText: HTMLElement | null = null;
    let zoomValue: HTMLElement | null = null;

    // ==========================================
    // EDITOR INIT
    // ==========================================
    let editorInitialized = false;

    async function initEditor() {
      if (editorInitialized) return;
      editorInitialized = true;

      viewer = document.getElementById('te-viewer');
      canvas = document.getElementById('te-canvas') as HTMLCanvasElement;
      if (!viewer || !canvas) return;
      ctx = canvas.getContext('2d');
      if (!ctx) return;
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';

      loadingEl = document.getElementById('te-loading');
      loadingText = document.getElementById('te-loading-text');
      zoomValue = document.getElementById('te-zoom-value');

      // Setup event listeners
      setupViewControls();
      setupClickHandler();
      setupSidebar();
      setupMasteryPopup();

      // Load data
      try {
        setLoadingText('Loading tree data...');
        const [treeResp, spritesResp] = await Promise.all([
          fetch(`${BASE_URL}data/pob-tree.json`),
          fetch(`${BASE_URL}data/pob-sprites.json`),
        ]);
        treeData = await treeResp.json();
        spritesData = await spritesResp.json();

        // Load skills.json from build-time injected data
        skillsData = (window as any).__SKILLS_DATA__ || null;

        console.log('[TE] Tree loaded:', Object.keys(treeData!.nodes).length, 'nodes');

        setLoadingText('Loading textures...');
        await loadAtlases();

        setLoadingText('Processing nodes...');
        processNodes();

        centerView();
        render();
        updateStats();
        populateSidebar();
      } catch (err) {
        console.error('[TE] Init error:', err);
        setLoadingText(`Error: ${err}`);
        return;
      }
      loadingEl?.classList.add('hidden');
    }

    function setLoadingText(text: string) {
      if (loadingText) loadingText.textContent = text;
    }

    // ==========================================
    // DATA LOADING (same as V2)
    // ==========================================
    async function loadAtlases() {
      if (!spritesData) return;

      const cdnToLocal: Record<string, string> = {};
      for (const [key, cat] of Object.entries(spritesData.sprites)) {
        const url = cat.filename;
        const match = url.match(/\/([^/?]+)(\?|$)/);
        if (match) {
          cdnToLocal[key] = `data/assets/${match[1]}`;
        }
      }

      const localAssets: Record<string, string> = {
        'PSGroupBackground1': 'data/assets/backgrounds/PSGroupBackground1.png',
        'PSGroupBackground2': 'data/assets/backgrounds/PSGroupBackground2.png',
        'PSGroupBackground3': 'data/assets/backgrounds/PSGroupBackground3.png',
      };

      const classNames = ['duelist','marauder','ranger','scion','shadow','templar','witch'];
      for (const name of classNames) {
        localAssets[`center${name}`] = `data/assets/classes/center${name}.png`;
      }

      // Class background images (full-screen behind tree)
      const classBgMap: Record<string, string> = {
        'BackgroundStr': 'data/assets/BackgroundStr.png',         // Marauder
        'BackgroundDex': 'data/assets/BackgroundDex.png',         // Ranger
        'BackgroundInt': 'data/assets/BackgroundInt.png',         // Witch
        'BackgroundStrDex': 'data/assets/BackgroundStrDex.png',   // Duelist
        'BackgroundStrInt': 'data/assets/BackgroundStrInt.png',   // Templar
        'BackgroundDexInt': 'data/assets/BackgroundDexInt.png',   // Shadow
      };
      for (const [key, path] of Object.entries(classBgMap)) {
        localAssets[key] = path;
      }

      const allAssets = { ...cdnToLocal, ...localAssets };
      const promises: Promise<void>[] = [];

      for (const [key, path] of Object.entries(allAssets)) {
        promises.push(new Promise((resolve) => {
          const img = new Image();
          img.onload = () => { atlases[key] = img; resolve(); };
          img.onerror = () => { console.warn(`[TE] Failed to load: ${key} (${path})`); resolve(); };
          img.src = `${BASE_URL}${path}`;
        }));
      }

      await Promise.all(promises);
      console.log('[TE] Atlases loaded:', Object.keys(atlases).length, '/', Object.keys(allAssets).length);
    }

    // ==========================================
    // NODE PROCESSING (same as V2)
    // ==========================================
    function processNodes() {
      if (!treeData) return;
      const { nodes, groups, constants } = treeData;
      const { orbitRadii, skillsPerOrbit } = constants;

      nodePositions.clear();

      for (const [nodeId, node] of Object.entries(nodes)) {
        if (nodeId === 'root') continue;
        if (node.group === undefined) continue;

        const group = groups[node.group];
        if (!group) continue;
        if (group.isProxy) continue;

        const orbit = node.orbit ?? 0;
        const orbitIndex = node.orbitIndex ?? 0;
        const radius = orbitRadii[orbit] ?? 0;
        const skillCount = skillsPerOrbit[orbit] ?? 1;

        const angle = (2 * Math.PI * orbitIndex) / skillCount;
        const x = group.x + radius * Math.sin(angle);
        const y = group.y - radius * Math.cos(angle);

        nodePositions.set(nodeId, { x, y, node });
      }

      ascendancyGroups.clear();
      ascStartGroups.clear();
      for (const [_nid, n] of Object.entries(nodes)) {
        if (n.ascendancyName && n.group !== undefined) {
          ascendancyGroups.set(String(n.group), n.ascendancyName);
        }
        if (n.isAscendancyStart && n.ascendancyName && n.group !== undefined) {
          ascStartGroups.set(n.ascendancyName, String(n.group));
        }
      }

      classStartGroups.clear();
      for (const [_nid, n] of Object.entries(nodes)) {
        if (n.classStartIndex !== undefined && n.group !== undefined) {
          const cls = treeData!.classes?.[n.classStartIndex];
          if (cls?.name) {
            classStartGroups.set(String(n.group), cls.name.toLowerCase());
          }
        }
      }

      // Build adjacency graph (bidirectional, skip classStart/mastery nodes)
      adjacency.clear();
      for (const [nodeId, node] of Object.entries(nodes)) {
        if (nodeId === 'root') continue;
        if (node.classStartIndex !== undefined) continue;
        if (node.isMastery) continue;
        if (node.isMultipleChoiceOption) continue;
        if (!nodePositions.has(nodeId)) continue;

        if (!adjacency.has(nodeId)) adjacency.set(nodeId, new Set());

        const connections = [...(node.out || []), ...(node.in || [])];
        for (const otherId of connections) {
          const oid = String(otherId);
          const otherNode = nodes[oid];
          if (!otherNode) continue;
          if (otherNode.classStartIndex !== undefined) continue;
          if (otherNode.isMastery) continue;
          if (otherNode.isMultipleChoiceOption) continue;
          if (!nodePositions.has(oid)) continue;

          adjacency.get(nodeId)!.add(oid);
          if (!adjacency.has(oid)) adjacency.set(oid, new Set());
          adjacency.get(oid)!.add(nodeId);
        }
      }

      // Build class -> startNodeId mapping
      // The classStartIndex center node connects to the first allocatable nodes
      // We need to find the nodes connected TO the classStart center node (those are the real starting nodes)
      classToStartNode.clear();
      classAscendancies.clear();
      for (const [nodeId, node] of Object.entries(nodes)) {
        if (node.classStartIndex !== undefined) {
          const cls = treeData!.classes?.[node.classStartIndex];
          if (cls?.name) {
            classToStartNode.set(cls.name, nodeId);
            // Collect ascendancies for this class
            const ascNames: string[] = [];
            if (cls.ascendancies) {
              for (const asc of cls.ascendancies) {
                if (asc?.name) ascNames.push(asc.name);
              }
            }
            classAscendancies.set(cls.name, ascNames);
          }
        }
      }

      console.log('[TE] Processed', nodePositions.size, 'node positions,', adjacency.size, 'in adjacency graph');
    }

    // ==========================================
    // SPRITE HELPERS (same as V2)
    // ==========================================
    function getCoords(category: string, key: string): SpriteCoord | null {
      const cat = spritesData?.sprites?.[category];
      if (!cat) return null;
      return cat.coords?.[key] ?? null;
    }

    function getAtlas(category: string): HTMLImageElement | null {
      return atlases[category] ?? null;
    }

    function drawSprite(category: string, key: string, dx: number, dy: number, dw: number, dh: number) {
      const atlas = getAtlas(category);
      const coords = getCoords(category, key);
      if (!atlas || !coords) return false;
      ctx!.drawImage(atlas, coords.x, coords.y, coords.w, coords.h, dx, dy, dw, dh);
      return true;
    }

    // ==========================================
    // RENDERING
    // ==========================================
    /** Check if a node should be visible given current class/ascendancy selection */
    function isNodeVisible(node: TreeNode): boolean {
      if (!node.ascendancyName) return true; // main tree always visible
      if (!selectedAscendancy) return false;  // no ascendancy selected -> hide all asc nodes
      return node.ascendancyName === selectedAscendancy;
    }

    function render() {
      if (!ctx || !canvas || !treeData) return;

      ctx.fillStyle = '#070710';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.save();
      ctx.translate(canvas.width / 2 + panX, canvas.height / 2 + panY);
      ctx.scale(zoom, zoom);

      renderClassBackground();
      renderBackground();
      renderGroupBackgrounds();
      renderConnections();
      renderMasteryEffects();
      renderNodes();
      renderHoverPreview();

      ctx.restore();
    }

    function renderBackground() {
      const coords = getCoords('background', 'Background2');
      const atlas = getAtlas('background');
      if (!coords || !atlas) return;

      const tileSize = coords.w * 3;
      const pad = 2000;
      const minX = treeData!.min_x - pad;
      const maxX = treeData!.max_x + pad;
      const minY = treeData!.min_y - pad;
      const maxY = treeData!.max_y + pad;

      ctx!.globalAlpha = 0.25;
      for (let x = minX; x < maxX; x += tileSize) {
        for (let y = minY; y < maxY; y += tileSize) {
          ctx!.drawImage(atlas, coords.x, coords.y, coords.w, coords.h, x, y, tileSize, tileSize);
        }
      }
      ctx!.globalAlpha = 1.0;

    }

    function renderClassBackground() {
      if (!selectedClass || !treeData || !classStartNodeId) return;
      const bgKey = classToBackground[selectedClass];
      const bgImg = bgKey ? atlases[bgKey] : null;
      if (!bgImg) return;

      // Position at the class's starting area
      const startNode = treeData.nodes[classStartNodeId];
      if (!startNode || startNode.group === undefined) return;
      const group = treeData.groups[startNode.group];
      if (!group) return;

      const scale = 5;
      const w = bgImg.width * scale;
      const h = bgImg.height * scale;
      ctx!.drawImage(bgImg, group.x - w / 2, group.y - h / 2, w, h);
    }

    function renderGroupBackgrounds() {
      if (!treeData) return;
      const groups = treeData.groups;

      for (const [gid, group] of Object.entries(groups)) {
        if (group.isProxy) continue;

        const ascName = ascendancyGroups.get(gid);
        if (ascName) {
          // Only show selected ascendancy background
          if (selectedAscendancy && ascName === selectedAscendancy && ascStartGroups.get(ascName) === gid) {
            const spriteKey = `Classes${ascName}`;
            const coords = getCoords('ascendancy', spriteKey);
            const atlas = getAtlas('ascendancy');
            if (coords && atlas) {
              const scale = 2.6;
              const w = coords.w * scale;
              const h = coords.h * scale;
              ctx!.save();
              ctx!.translate(group.x, group.y);
              ctx!.drawImage(atlas, coords.x, coords.y, coords.w, coords.h, -w / 2, -h / 2, w, h);
              ctx!.restore();
            }
          }
          continue;
        }

        const className = classStartGroups.get(gid);
        if (className) {
          const bgImg = atlases[`center${className}`] as HTMLImageElement | undefined;
          if (bgImg) {
            const scale = 2.6;
            const w = bgImg.width * scale;
            const h = bgImg.height * scale;
            ctx!.save();
            ctx!.translate(group.x, group.y);
            ctx!.drawImage(bgImg, -w / 2, -h / 2, w, h);
            ctx!.restore();
          }
          continue;
        }

        if (!group.background?.image) continue;

        const bgName = group.background.image;
        const bgImg = atlases[bgName] as HTMLImageElement | undefined;
        if (!bgImg) continue;

        const isHalf = group.background.isHalfImage;
        const scale = 2.6;
        const w = bgImg.width * scale;
        const h = bgImg.height * scale;

        ctx!.save();
        ctx!.translate(group.x, group.y);

        if (isHalf) {
          ctx!.drawImage(bgImg, -w / 2, -h, w, h);
          ctx!.save();
          ctx!.scale(1, -1);
          ctx!.drawImage(bgImg, -w / 2, -h, w, h);
          ctx!.restore();
        } else {
          ctx!.drawImage(bgImg, -w / 2, -h / 2, w, h);
        }

        ctx!.restore();
      }
    }

    function renderConnections() {
      if (!treeData || !spritesData) return;

      const lineAtlas = getAtlas('line');
      const lineNormalCoords = getCoords('line', 'LineConnectorNormal');
      const lineActiveCoords = getCoords('line', 'LineConnectorActive');
      if (!lineAtlas || !lineNormalCoords) return;

      const { orbitRadii, skillsPerOrbit } = treeData.constants;
      const groups = treeData.groups;

      const drawnConnections = new Set<string>();

      for (const [nodeId, pos] of nodePositions) {
        const node = pos.node;
        if (node.isMastery) continue;
        if (node.classStartIndex !== undefined) continue;
        if (!isNodeVisible(node)) continue;

        const connectedIds = [...(node.out || []), ...(node.in || [])];
        for (const outId of connectedIds) {
          const connKey = [nodeId, outId].sort().join('-');
          if (drawnConnections.has(connKey)) continue;
          drawnConnections.add(connKey);

          const targetPos = nodePositions.get(String(outId));
          if (!targetPos) continue;
          const targetNode = targetPos.node;
          if (targetNode.isMastery) continue;
          if (targetNode.classStartIndex !== undefined) continue;
          if (!isNodeVisible(targetNode)) continue;

          const srcAsc = !!node.ascendancyName;
          const tgtAsc = !!targetNode.ascendancyName;
          if (srcAsc !== tgtAsc) continue;

          // Use active line if both nodes are allocated
          const bothAllocated = allocatedNodes.has(nodeId) && allocatedNodes.has(String(outId));
          const lineCoords = (bothAllocated && lineActiveCoords) ? lineActiveCoords : lineNormalCoords;
          const lineHeight = lineCoords.h * 2.6;

          const sameGroup = node.group === targetNode.group;
          const sameOrbit = node.orbit === targetNode.orbit && node.orbit > 0;

          if (sameGroup && sameOrbit && !lineOnlyGroups.has(String(node.group))) {
            const group = groups[node.group];
            if (!group) continue;
            const radius = orbitRadii[node.orbit] || 0;
            if (radius === 0) continue;
            const count = skillsPerOrbit[node.orbit] || 1;

            const a1 = 2 * Math.PI * node.orbitIndex / count;
            const a2 = 2 * Math.PI * targetNode.orbitIndex / count;

            let diff = a2 - a1;
            if (diff > Math.PI) diff -= 2 * Math.PI;
            if (diff < -Math.PI) diff += 2 * Math.PI;

            const arcLen = Math.abs(diff) * radius;
            const segments = Math.max(8, Math.ceil(arcLen / 30));

            for (let i = 0; i < segments; i++) {
              const t1 = a1 + diff * (i / segments);
              const t2 = a1 + diff * ((i + 1) / segments);
              const x1 = group.x + radius * Math.sin(t1);
              const y1 = group.y - radius * Math.cos(t1);
              const x2 = group.x + radius * Math.sin(t2);
              const y2 = group.y - radius * Math.cos(t2);

              const sdx = x2 - x1;
              const sdy = y2 - y1;
              const segDist = Math.sqrt(sdx * sdx + sdy * sdy);
              const segAngle = Math.atan2(sdy, sdx);

              ctx!.save();
              ctx!.translate((x1 + x2) / 2, (y1 + y2) / 2);
              ctx!.rotate(segAngle);
              ctx!.drawImage(
                lineAtlas,
                lineCoords.x, lineCoords.y, lineCoords.w, lineCoords.h,
                -segDist / 2, -lineHeight / 2, segDist, lineHeight
              );
              ctx!.restore();
            }
            continue;
          }

          // Straight line connector
          const dx = targetPos.x - pos.x;
          const dy = targetPos.y - pos.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const angle = Math.atan2(dy, dx);

          ctx!.save();
          ctx!.translate((pos.x + targetPos.x) / 2, (pos.y + targetPos.y) / 2);
          ctx!.rotate(angle);
          ctx!.drawImage(
            lineAtlas,
            lineCoords.x, lineCoords.y, lineCoords.w, lineCoords.h,
            -distance / 2, -lineHeight / 2, distance, lineHeight
          );
          ctx!.restore();
        }
      }
    }

    /** Render mastery active effects as a separate layer BEFORE nodes so they don't cover neighboring nodes */
    function renderMasteryEffects() {
      if (!treeData || !spritesData) return;
      const masteryIconSize = 200;

      for (const [nodeId, pos] of nodePositions) {
        const node = pos.node;
        if (!node.isMastery) continue;
        if (!isNodeVisible(node)) continue;
        if (!allocatedMasteries.has(nodeId)) continue;
        if (!node.activeEffectImage) continue;

        const effectSize = masteryIconSize * 3;
        const halfEffect = effectSize / 2;
        const drew = drawSprite('masteryActiveEffect', node.activeEffectImage, pos.x - halfEffect, pos.y - halfEffect, effectSize, effectSize);
        if (!drew) {
          ctx!.save();
          ctx!.globalAlpha = 0.3;
          const grad = ctx!.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, halfEffect);
          grad.addColorStop(0, '#4488ff');
          grad.addColorStop(1, 'transparent');
          ctx!.fillStyle = grad;
          ctx!.beginPath();
          ctx!.arc(pos.x, pos.y, halfEffect, 0, Math.PI * 2);
          ctx!.fill();
          ctx!.restore();
        }
      }
    }

    function renderNodes() {
      if (!treeData || !spritesData) return;

      const sizes: Record<string, { icon: number; frame: number }> = {
        normal:     { icon: 75,  frame: 100 },
        notable:    { icon: 100, frame: 130 },
        keystone:   { icon: 170, frame: 220 },
        mastery:    { icon: 200, frame: 0 },
        jewel:      { icon: 110, frame: 145 },
        clusterSmall:  { icon: 110, frame: 145 },
        clusterMedium: { icon: 110, frame: 145 },
        clusterLarge:  { icon: 110, frame: 145 },
        ascNotable: { icon: 100, frame: 135 },
        ascSmall:   { icon: 75,  frame: 100 },
      };

      for (const [nodeId, pos] of nodePositions) {
        const node = pos.node;
        if (node.classStartIndex !== undefined) continue;
        if (!isNodeVisible(node)) continue;

        const isAsc = !!node.ascendancyName;
        const isAllocated = allocatedNodes.has(nodeId);

        // Determine node type
        let type = 'normal';
        if (node.isKeystone) type = 'keystone';
        else if (node.isNotable) type = isAsc ? 'ascNotable' : 'notable';
        else if (node.isMastery) type = 'mastery';
        else if (node.isJewelSocket && node.expansionJewel) {
          const s = node.expansionJewel.size;
          type = s === 2 ? 'clusterLarge' : s === 1 ? 'clusterMedium' : 'clusterSmall';
        }
        else if (node.isJewelSocket) type = 'jewel';
        else if (isAsc) type = 'ascSmall';

        const size = sizes[type] || sizes.normal;
        const halfIcon = size.icon / 2;
        const halfFrame = size.frame / 2;

        // 1. Draw icon (active or inactive based on allocation)
        if (type === 'mastery') {
          const hasMasteryEffect = allocatedMasteries.has(nodeId);
          if (hasMasteryEffect) {
            // Active mastery icon (effect already drawn in renderMasteryEffects)
            let drewIcon = false;
            if (node.activeIcon) {
              drewIcon = drawSprite('masteryActiveSelected', node.activeIcon, pos.x - halfIcon, pos.y - halfIcon, size.icon, size.icon);
            }
            // Fallback: draw inactive icon with green glow ring
            if (!drewIcon && node.inactiveIcon) {
              drawSprite('masteryConnected', node.inactiveIcon, pos.x - halfIcon, pos.y - halfIcon, size.icon, size.icon);
              ctx!.save();
              ctx!.strokeStyle = '#4a8a3a';
              ctx!.lineWidth = 8;
              ctx!.shadowColor = '#4a8a3a';
              ctx!.shadowBlur = 15;
              ctx!.beginPath();
              ctx!.arc(pos.x, pos.y, halfIcon * 0.9, 0, Math.PI * 2);
              ctx!.stroke();
              ctx!.restore();
            }
          } else if (node.inactiveIcon) {
            drawSprite('masteryConnected', node.inactiveIcon, pos.x - halfIcon, pos.y - halfIcon, size.icon, size.icon);
          }
        } else if (node.icon) {
          let iconCategory: string;
          if (isAllocated) {
            // Use active sprites for allocated nodes
            if (type === 'keystone') iconCategory = 'keystoneActive';
            else if (type === 'notable' || type === 'ascNotable') iconCategory = 'notableActive';
            else iconCategory = 'normalActive';
          } else {
            // Inactive sprites
            if (type === 'keystone') iconCategory = 'keystoneInactive';
            else if (type === 'notable' || type === 'ascNotable') iconCategory = 'notableInactive';
            else iconCategory = 'normalInactive';
          }

          drawSprite(iconCategory, node.icon, pos.x - halfIcon, pos.y - halfIcon, size.icon, size.icon);
        }

        // 2. Draw frame (allocated or unallocated)
        if (size.frame > 0) {
          let frameName = '';
          let frameCategory = 'frame';

          if (type === 'ascNotable') {
            frameName = isAllocated ? 'AscendancyFrameLargeAllocated' : 'AscendancyFrameLargeNormal';
            frameCategory = 'ascendancy';
          } else if (type === 'ascSmall') {
            frameName = isAllocated ? 'AscendancyFrameSmallAllocated' : 'AscendancyFrameSmallNormal';
            frameCategory = 'ascendancy';
          } else if (type === 'keystone') {
            frameName = isAllocated ? 'KeystoneFrameAllocated' : 'KeystoneFrameUnallocated';
          } else if (type === 'notable') {
            frameName = isAllocated ? 'NotableFrameAllocated' : 'NotableFrameUnallocated';
          } else if (type === 'jewel') {
            frameName = isAllocated ? 'JewelFrameAllocated' : 'JewelFrameUnallocated';
          } else if (type === 'clusterSmall') {
            frameName = isAllocated ? 'JewelSocketAltActive' : 'JewelSocketClusterAltNormal1Small';
          } else if (type === 'clusterMedium') {
            frameName = isAllocated ? 'JewelSocketAltActive' : 'JewelSocketClusterAltNormal1Medium';
          } else if (type === 'clusterLarge') {
            frameName = isAllocated ? 'JewelSocketAltActive' : 'JewelSocketClusterAltNormal1Large';
          } else {
            frameName = isAllocated ? 'PSSkillFrameActive' : 'PSSkillFrame';
          }

          drawSprite(frameCategory, frameName, pos.x - halfFrame, pos.y - halfFrame, size.frame, size.frame);
        }
      }
    }

    function renderHoverPreview() {
      if (!ctx) return;

      // Green path preview (allocation)
      if (hoverPreviewPath.length > 0) {
        ctx.save();

        // Draw green lines along the path
        ctx.strokeStyle = '#00ff66';
        ctx.lineWidth = 12;
        ctx.globalAlpha = 0.6;
        ctx.lineCap = 'round';

        for (let i = 0; i < hoverPreviewPath.length - 1; i++) {
          const p1 = nodePositions.get(hoverPreviewPath[i]);
          const p2 = nodePositions.get(hoverPreviewPath[i + 1]);
          if (p1 && p2) {
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
          }
        }

        // Draw green glow on new (unallocated) path nodes
        ctx.globalAlpha = 0.35;
        ctx.fillStyle = '#00ff66';
        for (const nid of hoverPreviewPath) {
          if (allocatedNodes.has(nid)) continue;
          const pos = nodePositions.get(nid);
          if (pos) {
            const node = pos.node;
            const radius = node.isKeystone ? 60 : (node.isNotable ? 50 : 35);
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        ctx.restore();
      }

      // Red deallocation preview
      if (hoverOrphans.size > 0) {
        ctx.save();

        // Draw red glow on nodes that would be removed
        ctx.globalAlpha = 0.4;
        ctx.fillStyle = '#ff3333';
        for (const nid of hoverOrphans) {
          const pos = nodePositions.get(nid);
          if (pos) {
            const node = pos.node;
            const radius = node.isKeystone ? 65 : (node.isNotable ? 55 : 40);
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        // Draw red lines between orphan connections
        ctx.strokeStyle = '#ff3333';
        ctx.lineWidth = 10;
        ctx.globalAlpha = 0.5;
        ctx.lineCap = 'round';
        const drawnLines = new Set<string>();
        for (const nid of hoverOrphans) {
          const pos = nodePositions.get(nid);
          if (!pos) continue;
          const neighbors = adjacency.get(nid);
          if (!neighbors) continue;
          for (const nnid of neighbors) {
            if (!hoverOrphans.has(nnid)) continue;
            const lineKey = [nid, nnid].sort().join('-');
            if (drawnLines.has(lineKey)) continue;
            drawnLines.add(lineKey);
            const npos = nodePositions.get(nnid);
            if (npos) {
              ctx.beginPath();
              ctx.moveTo(pos.x, pos.y);
              ctx.lineTo(npos.x, npos.y);
              ctx.stroke();
            }
          }
        }

        ctx.restore();
      }
    }

    // ==========================================
    // CLICK-TO-ALLOCATE
    // ==========================================
    function setupClickHandler() {
      if (!viewer || !canvas) return;

      let pointerDownPos = { x: 0, y: 0 };

      viewer.addEventListener('pointerdown', (e) => {
        pointerDownPos = { x: e.clientX, y: e.clientY };
      });

      viewer.addEventListener('pointerup', (e) => {
        // Only handle clicks (not drags)
        const dx = e.clientX - pointerDownPos.x;
        const dy = e.clientY - pointerDownPos.y;
        if (Math.sqrt(dx * dx + dy * dy) > 5) return; // was a drag

        // Close mastery popup if open and click is outside it
        const masteryPopup = document.getElementById('te-mastery-popup');
        if (masteryPopup && masteryPopup.style.display !== 'none') {
          if (!masteryPopup.contains(e.target as Node)) {
            hideMasteryPopup();
          }
          return;
        }

        // Convert screen coords to world coords
        const rect = canvas!.getBoundingClientRect();
        const screenX = e.clientX - rect.left;
        const screenY = e.clientY - rect.top;

        const worldX = (screenX - canvas!.width / 2 - panX) / zoom;
        const worldY = (screenY - canvas!.height / 2 - panY) / zoom;

        // Find nearest node within hit radius
        const hitRadii: Record<string, number> = {
          normal: 50,
          notable: 65,
          keystone: 110,
          mastery: 100,
          jewel: 72,
          clusterSmall: 72, clusterMedium: 72, clusterLarge: 72,
          ascNotable: 67,
          ascSmall: 50,
        };

        let closestId: string | null = null;
        let closestDist = Infinity;

        for (const [nodeId, pos] of nodePositions) {
          const node = pos.node;
          if (node.classStartIndex !== undefined) continue;
          if (node.isMultipleChoiceOption) continue;
          if (!isNodeVisible(node)) continue;

          // Determine type for hit radius
          let type = 'normal';
          if (node.isKeystone) type = 'keystone';
          else if (node.isNotable) type = node.ascendancyName ? 'ascNotable' : 'notable';
          else if (node.isMastery) type = 'mastery';
          else if (node.isJewelSocket && node.expansionJewel) {
            const s = node.expansionJewel.size;
            type = s === 2 ? 'clusterLarge' : s === 1 ? 'clusterMedium' : 'clusterSmall';
          }
          else if (node.isJewelSocket) type = 'jewel';
          else if (node.ascendancyName) type = 'ascSmall';

          const hitR = hitRadii[type] || 50;
          const ndx = worldX - pos.x;
          const ndy = worldY - pos.y;
          const dist = Math.sqrt(ndx * ndx + ndy * ndy);

          if (dist < hitR && dist < closestDist) {
            closestDist = dist;
            closestId = nodeId;
          }
        }

        if (closestId) {
          hideNodeTooltip();
          hoveredNodeId = null;
          const clickedNode = nodePositions.get(closestId)?.node;
          if (clickedNode?.isMastery) {
            handleMasteryClick(closestId);
          } else {
            toggleNode(closestId);
          }
        }
      });

      // Hover detection for preview
      viewer.addEventListener('pointermove', (e) => {
        if (isPanning) {
          if (hoveredNodeId !== null) {
            hoveredNodeId = null;
            hoverPreviewPath = [];
            hoverOrphans.clear();
            viewer!.style.cursor = '';
            hideNodeTooltip();
          }
          return;
        }

        cancelAnimationFrame(hoverRafId);
        hoverRafId = requestAnimationFrame(() => {
          const rect = canvas!.getBoundingClientRect();
          const screenX = e.clientX - rect.left;
          const screenY = e.clientY - rect.top;
          updateHover(screenX, screenY);
        });
      });

      viewer.addEventListener('pointerleave', () => {
        if (hoveredNodeId !== null) {
          hoveredNodeId = null;
          hoverPreviewPath = [];
          hoverOrphans.clear();
          viewer!.style.cursor = '';
          hideNodeTooltip();
          render();
        }
      });
    }

    /** Get the set of node IDs directly connected to the class start center node (first allocatable nodes) */
    function getClassStartNeighbors(): Set<string> {
      if (!classStartNodeId || !treeData) return new Set();
      const centerNode = treeData.nodes[classStartNodeId];
      if (!centerNode) return new Set();
      const neighbors = new Set<string>();
      const connections = [...(centerNode.out || []), ...(centerNode.in || [])];
      for (const id of connections) {
        const sid = String(id);
        if (nodePositions.has(sid)) neighbors.add(sid);
      }
      return neighbors;
    }

    /** Check if a node is adjacent to ANY allocated node or to the class start */
    function isAdjacentToAllocated(nodeId: string): boolean {
      // Check if adjacent to class start area
      const startNeighbors = getClassStartNeighbors();
      if (startNeighbors.has(nodeId)) return true;

      // Check if adjacent to any already-allocated node
      const neighbors = adjacency.get(nodeId);
      if (!neighbors) return false;
      for (const nid of neighbors) {
        if (allocatedNodes.has(nid)) return true;
      }
      return false;
    }

    /** BFS shortest path from any allocated node (or class start neighbors) to target */
    function findPathToNode(targetId: string, fullPath = false): string[] | null {
      if (!treeData) return null;

      const targetNode = nodePositions.get(targetId)?.node;
      if (!targetNode) return null;
      const targetIsAsc = !!targetNode.ascendancyName;

      // Start nodes for BFS: all allocated nodes + class start neighbor nodes
      const startSet = new Set<string>(allocatedNodes);
      const startNeighbors = getClassStartNeighbors();
      for (const sn of startNeighbors) startSet.add(sn);

      if (startSet.has(targetId)) return [targetId];

      // BFS from target backwards to find nearest allocated/start node
      const visited = new Map<string, string>(); // nodeId -> parent
      const queue: string[] = [targetId];
      visited.set(targetId, '');

      while (queue.length > 0) {
        const current = queue.shift()!;
        const neighbors = adjacency.get(current);
        if (!neighbors) continue;

        for (const nid of neighbors) {
          if (visited.has(nid)) continue;

          // Don't cross ascendancy/main boundary
          const nNode = nodePositions.get(nid)?.node;
          if (!nNode) continue;
          const nIsAsc = !!nNode.ascendancyName;
          if (nIsAsc !== targetIsAsc) continue;

          // If target is ascendancy, only path through same ascendancy
          if (targetIsAsc && nNode.ascendancyName && nNode.ascendancyName !== targetNode.ascendancyName) continue;

          visited.set(nid, current);

          if (startSet.has(nid)) {
            // Reconstruct path from nid to targetId
            const path: string[] = [];
            let cur = nid;
            while (cur !== '') {
              path.push(cur);
              cur = visited.get(cur) || '';
            }
            return fullPath ? path : path.filter(id => !allocatedNodes.has(id));
          }

          queue.push(nid);
        }
      }

      return null; // no path found
    }

    /** Flood fill from class start through allocated nodes; return all reachable allocated node IDs */
    function findReachable(excludeNodes?: Set<string>): Set<string> {
      const remaining = new Set(allocatedNodes);
      if (excludeNodes) {
        for (const nid of excludeNodes) remaining.delete(nid);
      }
      if (remaining.size === 0) return new Set();

      const reachable = new Set<string>();
      const startNeighbors = getClassStartNeighbors();
      const queue: string[] = [];

      for (const sn of startNeighbors) {
        if (remaining.has(sn)) {
          reachable.add(sn);
          queue.push(sn);
        }
      }

      while (queue.length > 0) {
        const current = queue.shift()!;
        const neighbors = adjacency.get(current);
        if (!neighbors) continue;
        for (const nid of neighbors) {
          if (remaining.has(nid) && !reachable.has(nid)) {
            reachable.add(nid);
            queue.push(nid);
          }
        }
      }

      return reachable;
    }

    /** Find nodes that would become orphaned if nodeId is removed */
    function findOrphansIfRemoved(nodeId: string): Set<string> {
      const excluded = new Set([nodeId]);
      const reachable = findReachable(excluded);

      const orphans = new Set<string>();
      for (const nid of allocatedNodes) {
        if (nid === nodeId) continue;
        if (!reachable.has(nid)) orphans.add(nid);
      }

      return orphans;
    }

    function toggleNode(nodeId: string) {
      if (!selectedClass) {
        setInfo('Select a class first before allocating nodes.');
        return;
      }

      const pos = nodePositions.get(nodeId);
      if (!pos) return;

      // If node belongs to a different ascendancy than selected, block it
      if (pos.node.ascendancyName && selectedAscendancy && pos.node.ascendancyName !== selectedAscendancy) {
        setInfo(`Cannot allocate: node belongs to ${pos.node.ascendancyName}, not ${selectedAscendancy}.`);
        return;
      }
      // Block ascendancy nodes if no ascendancy selected
      if (pos.node.ascendancyName && !selectedAscendancy) {
        setInfo('Select an ascendancy first to allocate ascendancy nodes.');
        return;
      }

      if (allocatedNodes.has(nodeId)) {
        // CASCADE DEALLOCATION: remove node + any orphaned nodes
        const orphans = findOrphansIfRemoved(nodeId);
        allocatedNodes.delete(nodeId);
        for (const oid of orphans) {
          allocatedNodes.delete(oid);
        }
        const total = 1 + orphans.size;
        setInfo(`Deallocated ${total} node${total > 1 ? 's' : ''}.`);
      } else {
        // ALLOCATION: check if adjacent or find path
        if (isAdjacentToAllocated(nodeId)) {
          allocatedNodes.add(nodeId);
          setInfo(`Allocated 1 node.`);
        } else {
          // Try to find shortest path
          const path = findPathToNode(nodeId);
          if (path && path.length > 0) {
            for (const pid of path) {
              allocatedNodes.add(pid);
            }
            setInfo(`Auto-pathed ${path.length} node${path.length > 1 ? 's' : ''}.`);
          } else {
            setInfo('Cannot reach this node from your current tree.');
            return;
          }
        }
      }

      // Clear hover preview (will recalculate on next mousemove)
      hoveredNodeId = null;
      hoverPreviewPath = [];
      hoverOrphans.clear();

      render();
      updatePointCounters();
      updateStats();
    }

    // ==========================================
    // MASTERY SUPPORT
    // ==========================================
    /** Find shortest path to any of the mastery's connected nodes */
    function findPathToMastery(masteryId: string): string[] | null {
      const node = treeData?.nodes[masteryId];
      if (!node) return null;
      const connections = [...(node.out || []), ...(node.in || [])];

      // If any connected node is already allocated, no path needed
      for (const cid of connections) {
        if (allocatedNodes.has(String(cid))) return [];
      }

      // If any connected node is a class start neighbor, no path needed
      const startNeighbors = getClassStartNeighbors();
      for (const cid of connections) {
        if (startNeighbors.has(String(cid))) return [String(cid)];
      }

      // Find shortest path to any connected node
      let bestPath: string[] | null = null;
      for (const cid of connections) {
        const sid = String(cid);
        if (!nodePositions.has(sid)) continue;
        const path = findPathToNode(sid);
        if (path && (bestPath === null || path.length < bestPath.length)) {
          bestPath = path;
        }
      }
      return bestPath;
    }

    function handleMasteryClick(nodeId: string) {
      const node = treeData?.nodes[nodeId];
      if (!node || !node.isMastery) return;

      if (!selectedClass) {
        setInfo('Select a class first before allocating nodes.');
        return;
      }

      // If already has an effect, just reopen popup to change/remove it
      if (allocatedMasteries.has(nodeId)) {
        pendingMasteryPath = [];
        activeMasteryNodeId = nodeId;
        showMasteryPopup(nodeId);
        return;
      }

      // Find path to reach this mastery
      const path = findPathToMastery(nodeId);
      if (path === null) {
        setInfo('Cannot reach this mastery from your current tree.');
        return;
      }

      // Store pending path - will be allocated only when an effect is chosen
      pendingMasteryPath = path;
      activeMasteryNodeId = nodeId;
      showMasteryPopup(nodeId);
    }

    function showMasteryPopup(nodeId: string) {
      const popup = document.getElementById('te-mastery-popup');
      const effectsContainer = document.getElementById('te-mastery-popup-effects');
      const titleEl = document.getElementById('te-mastery-popup-title');
      const clearBtn = document.getElementById('te-mastery-popup-clear');
      if (!popup || !effectsContainer || !canvas) return;

      const node = treeData?.nodes[nodeId];
      if (!node?.masteryEffects || node.masteryEffects.length === 0) {
        setInfo('This mastery has no available effects.');
        return;
      }

      if (titleEl) titleEl.textContent = node.name || 'Select Mastery Effect';

      // Set mastery header images
      setHeaderImages(headerAssetMap.mastery, 'te-popup-header-left', 'te-popup-header-mid', 'te-popup-header-right');

      // Show clear button only if mastery already has a selection
      const hasEffect = allocatedMasteries.has(nodeId);
      if (clearBtn) clearBtn.style.display = hasEffect ? '' : 'none';

      // Populate effect options
      effectsContainer.innerHTML = '';
      const currentEffect = allocatedMasteries.get(nodeId);

      const frameBulletUrl = `${BASE_URL}data/assets/frames/NotableFrameUnallocated.png`;

      for (const me of node.masteryEffects) {
        const btn = document.createElement('button');
        btn.className = 'te-mastery-effect-option' + (me.effect === currentEffect ? ' selected' : '');
        // Add NotableFrame bullet + text
        const bulletImg = document.createElement('img');
        bulletImg.src = frameBulletUrl;
        bulletImg.style.cssText = 'width:18px;height:18px;flex-shrink:0;margin-top:2px;opacity:0.7;';
        const textSpan = document.createElement('span');
        textSpan.textContent = me.stats.join(' / ');
        btn.appendChild(bulletImg);
        btn.appendChild(textSpan);
        btn.addEventListener('click', () => {
          console.log('[TE] Mastery effect clicked:', nodeId, 'effect:', me.effect, 'stats:', me.stats[0]);
          // Allocate the pending path nodes first
          if (pendingMasteryPath.length > 0) {
            for (const pid of pendingMasteryPath) {
              allocatedNodes.add(pid);
            }
            console.log('[TE] Auto-pathed', pendingMasteryPath.length, 'nodes:', pendingMasteryPath);
          }
          allocatedMasteries.set(nodeId, me.effect);
          console.log('[TE] allocatedMasteries now has', allocatedMasteries.size, 'entries:', [...allocatedMasteries.entries()]);
          const pathCount = pendingMasteryPath.filter(id => !allocatedNodes.has(id) || pendingMasteryPath.includes(id)).length;
          hideMasteryPopup();
          render();
          updatePointCounters();
          updateStats();
          setInfo(pathCount > 0
            ? `Mastery effect selected (auto-pathed ${pathCount} nodes): ${me.stats[0]}`
            : `Mastery effect: ${me.stats[0]}`);
        });
        effectsContainer.appendChild(btn);
      }

      // Position popup near the node on screen
      const pos = nodePositions.get(nodeId);
      if (pos) {
        const screenX = pos.x * zoom + canvas.width / 2 + panX;
        const screenY = pos.y * zoom + canvas.height / 2 + panY;
        popup.style.left = `${Math.max(0, Math.min(screenX + 20, canvas.width - 320))}px`;
        popup.style.top = `${Math.max(0, Math.min(screenY - 50, canvas.height - 340))}px`;
      }

      popup.style.display = '';
    }

    function hideMasteryPopup() {
      const popup = document.getElementById('te-mastery-popup');
      if (popup) popup.style.display = 'none';
      activeMasteryNodeId = null;
      pendingMasteryPath = [];
    }

    function setupMasteryPopup() {
      document.getElementById('te-mastery-popup-close')?.addEventListener('click', hideMasteryPopup);
      document.getElementById('te-mastery-popup-clear')?.addEventListener('click', () => {
        if (activeMasteryNodeId) {
          allocatedMasteries.delete(activeMasteryNodeId);
          hideMasteryPopup();
          render();
          updatePointCounters();
          updateStats();
          setInfo('Mastery effect removed.');
        }
      });
    }

    // ==========================================
    // NODE TOOLTIP
    // ==========================================
    // Header asset prefix map
    const headerAssetMap: Record<string, string> = {
      normal: 'normalpassiveheader',
      notable: 'notablepassiveheader',
      keystone: 'keystonepassiveheader',
      mastery: 'masteryheaderallocated',
      jewel: 'jewelpassiveheader',
    };

    function setHeaderImages(prefix: string, leftId: string, midId: string, rightId: string) {
      const leftImg = document.getElementById(leftId) as HTMLImageElement | null;
      const midDiv = document.getElementById(midId) as HTMLElement | null;
      const rightImg = document.getElementById(rightId) as HTMLImageElement | null;
      const base = `${BASE_URL}data/assets/`;
      if (leftImg) leftImg.src = `${base}${prefix}left.png`;
      if (midDiv) midDiv.style.backgroundImage = `url('${base}${prefix}middle.png')`;
      if (rightImg) rightImg.src = `${base}${prefix}right.png`;
    }

    function getNodeHeaderType(node: any): string {
      if (node.isKeystone) return 'keystone';
      if (node.isNotable) return 'notable';
      if (node.isMastery) return 'mastery';
      if (node.isJewelSocket) return 'jewel';
      return 'normal';
    }

    function showNodeTooltip(nodeId: string, screenX: number, screenY: number) {
      const tooltip = document.getElementById('te-node-tooltip');
      const nameEl = document.getElementById('te-tooltip-name');
      const bodyEl = document.getElementById('te-tooltip-body');
      if (!tooltip || !nameEl || !bodyEl) return;

      const pos = nodePositions.get(nodeId);
      if (!pos) return;
      const node = pos.node;

      // Set header images based on node type
      const headerType = getNodeHeaderType(node);
      const prefix = headerAssetMap[headerType] || headerAssetMap.normal;
      setHeaderImages(prefix, 'te-tooltip-header-left', 'te-tooltip-header-mid', 'te-tooltip-header-right');

      // Set name
      nameEl.textContent = node.name || 'Passive';

      // Build body content
      let html = '';

      if (node.isMastery) {
        // Mastery: show selected effect or available effects
        const frameBullet = `${BASE_URL}data/assets/frames/NotableFrameUnallocated.png`;
        const selectedEffect = allocatedMasteries.get(nodeId);
        if (selectedEffect !== undefined && node.masteryEffects) {
          const me = node.masteryEffects.find(e => e.effect === selectedEffect);
          if (me) {
            html += '<div class="te-tooltip-mastery-label">Selected Effect:</div>';
            for (const stat of me.stats) {
              html += `<div class="te-tooltip-mastery-effect"><img src="${frameBullet}" alt=""><span class="te-tooltip-mastery-effect-text" style="color:#4a8a3a;">${stat}</span></div>`;
            }
          }
        } else if (node.masteryEffects && node.masteryEffects.length > 0) {
          html += '<div class="te-tooltip-mastery-label">Click to select an effect</div>';
          for (const me of node.masteryEffects) {
            html += '<hr class="te-tooltip-separator">';
            for (const stat of me.stats) {
              html += `<div class="te-tooltip-mastery-effect"><img src="${frameBullet}" alt=""><span class="te-tooltip-mastery-effect-text">${stat}</span></div>`;
            }
          }
        }
      } else {
        // Normal/Notable/Keystone: show stats
        if (node.stats && node.stats.length > 0) {
          for (const stat of node.stats) {
            html += `<div class="te-tooltip-stat">${stat}</div>`;
          }
        }
        if (node.reminderText && node.reminderText.length > 0) {
          for (const rt of node.reminderText) {
            html += `<div class="te-tooltip-reminder">${rt}</div>`;
          }
        }
      }

      if (!html) {
        hideNodeTooltip();
        return;
      }

      bodyEl.innerHTML = html;
      tooltip.style.display = '';
      updateTooltipPosition(screenX, screenY);
    }

    function updateTooltipPosition(screenX: number, screenY: number) {
      const tooltip = document.getElementById('te-node-tooltip');
      if (!tooltip || !viewer) return;

      const viewerRect = viewer.getBoundingClientRect();
      const tooltipRect = tooltip.getBoundingClientRect();

      // Position to the right of cursor, offset slightly
      let left = screenX + 15;
      let top = screenY - 10;

      // Clamp to stay within the viewer bounds
      if (left + tooltipRect.width > viewerRect.width) {
        left = screenX - tooltipRect.width - 15;
      }
      if (top + tooltipRect.height > viewerRect.height) {
        top = viewerRect.height - tooltipRect.height - 5;
      }
      if (top < 0) top = 5;

      tooltip.style.left = `${left}px`;
      tooltip.style.top = `${top}px`;
    }

    function hideNodeTooltip() {
      const tooltip = document.getElementById('te-node-tooltip');
      if (tooltip) tooltip.style.display = 'none';
    }

    /** Update hover preview based on screen coordinates */
    function updateHover(screenX: number, screenY: number) {
      if (!canvas) return;

      const worldX = (screenX - canvas.width / 2 - panX) / zoom;
      const worldY = (screenY - canvas.height / 2 - panY) / zoom;

      const hitRadii: Record<string, number> = {
        normal: 50, notable: 65, keystone: 110, mastery: 100,
        jewel: 72, clusterSmall: 72, clusterMedium: 72, clusterLarge: 72,
        ascNotable: 67, ascSmall: 50,
      };

      let closestId: string | null = null;
      let closestDist = Infinity;

      for (const [nodeId, pos] of nodePositions) {
        const node = pos.node;
        if (node.classStartIndex !== undefined) continue;
        if (node.isMultipleChoiceOption) continue;
        if (!isNodeVisible(node)) continue;

        let type = 'normal';
        if (node.isKeystone) type = 'keystone';
        else if (node.isNotable) type = node.ascendancyName ? 'ascNotable' : 'notable';
        else if (node.isMastery) type = 'mastery';
        else if (node.isJewelSocket && node.expansionJewel) {
          const s = node.expansionJewel.size;
          type = s === 2 ? 'clusterLarge' : s === 1 ? 'clusterMedium' : 'clusterSmall';
        }
        else if (node.isJewelSocket) type = 'jewel';
        else if (node.ascendancyName) type = 'ascSmall';

        const hitR = hitRadii[type] || 50;
        const dx = worldX - pos.x;
        const dy = worldY - pos.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < hitR && dist < closestDist) {
          closestDist = dist;
          closestId = nodeId;
        }
      }

      if (closestId === hoveredNodeId) {
        // Same node - just update tooltip position
        if (closestId) updateTooltipPosition(screenX, screenY);
        return;
      }

      hoveredNodeId = closestId;
      hoverPreviewPath = [];
      hoverOrphans.clear();

      if (closestId) {
        const hovNode = nodePositions.get(closestId)?.node;

        if (hovNode?.isMastery) {
          // Mastery: show green path preview if reachable
          if (allocatedMasteries.has(closestId)) {
            viewer!.style.cursor = 'pointer';
          } else if (selectedClass) {
            const mPath = findPathToMastery(closestId);
            if (mPath !== null) {
              viewer!.style.cursor = 'pointer';
              // Show the path as green preview (full path including allocated)
              if (mPath.length > 0) {
                const fullPath = findPathToNode(mPath[mPath.length - 1], true);
                if (fullPath) hoverPreviewPath = fullPath;
              }
            } else {
              viewer!.style.cursor = '';
            }
          } else {
            viewer!.style.cursor = '';
          }
        } else {
          viewer!.style.cursor = 'pointer';

          if (allocatedNodes.has(closestId)) {
            // Red preview: show cascade deallocation
            hoverOrphans = findOrphansIfRemoved(closestId);
            hoverOrphans.add(closestId);
          } else if (selectedClass) {
            // Green preview: show path to allocate
            const path = findPathToNode(closestId, true);
            if (path) hoverPreviewPath = path;
          }
        }

        // Show tooltip for the hovered node
        showNodeTooltip(closestId, screenX, screenY);
      } else {
        viewer!.style.cursor = '';
        hideNodeTooltip();
      }

      render();
    }

    // ==========================================
    // POINT COUNTERS
    // ==========================================
    function updatePointCounters() {
      let mainPoints = 0;
      let ascPoints = 0;

      for (const nodeId of allocatedNodes) {
        const pos = nodePositions.get(nodeId);
        if (!pos) continue;
        if (pos.node.ascendancyName) {
          ascPoints++;
        } else {
          mainPoints++;
        }
      }

      // Each mastery with a selected effect costs 1 passive point
      mainPoints += allocatedMasteries.size;

      const mainEl = document.getElementById('te-main-points');
      const ascEl = document.getElementById('te-asc-points');
      if (mainEl) mainEl.textContent = `${mainPoints} / 123`;
      if (ascEl) ascEl.textContent = `${ascPoints} / 8`;
    }

    function updateStats() {
      const statNodes = document.getElementById('te-stat-nodes');
      const statGroups = document.getElementById('te-stat-groups');
      const statAlloc = document.getElementById('te-stat-allocated');

      if (statNodes) statNodes.textContent = `Nodes: ${nodePositions.size}`;
      if (statGroups && treeData) statGroups.textContent = `Groups: ${Object.keys(treeData.groups).length}`;
      if (statAlloc) statAlloc.textContent = `Allocated: ${allocatedNodes.size}`;
    }

    // ==========================================
    // SIDEBAR LOGIC
    // ==========================================
    function populateClassDropdown() {
      if (!treeData) return;
      const classSelect = document.getElementById('te-class-select') as HTMLSelectElement;
      if (!classSelect) return;

      classSelect.innerHTML = '<option value="">(Select Class)</option>';
      for (const cls of treeData.classes) {
        if (!cls?.name) continue;
        const opt = document.createElement('option');
        opt.value = cls.name;
        opt.textContent = cls.name;
        classSelect.appendChild(opt);
      }

      classSelect.addEventListener('change', () => {
        onClassChange(classSelect.value);
      });
    }

    function onClassChange(className: string) {
      selectedClass = className;
      selectedAscendancy = '';
      classStartNodeId = classToStartNode.get(className) || '';
      allocatedNodes.clear();
      allocatedMasteries.clear();

      // Populate ascendancy dropdown
      const ascSelect = document.getElementById('te-asc-select') as HTMLSelectElement;
      if (ascSelect) {
        ascSelect.innerHTML = '<option value="">(None)</option>';
        const ascNames = classAscendancies.get(className) || [];
        for (const name of ascNames) {
          const opt = document.createElement('option');
          opt.value = name;
          opt.textContent = name;
          ascSelect.appendChild(opt);
        }
      }

      render();
      updatePointCounters();
      updateStats();

      if (className) {
        setInfo(`Class set to ${className}. Click nodes near the ${className} starting area to begin.`);
      } else {
        setInfo('Select a class to begin allocating.');
      }
    }

    function onAscendancyChange(ascName: string) {
      selectedAscendancy = ascName;
      // Remove any allocated nodes from other ascendancies
      for (const nodeId of [...allocatedNodes]) {
        const pos = nodePositions.get(nodeId);
        if (pos?.node.ascendancyName && pos.node.ascendancyName !== ascName) {
          allocatedNodes.delete(nodeId);
        }
      }
      render();
      updatePointCounters();
      updateStats();
      if (ascName) {
        setInfo(`Ascendancy set to ${ascName}.`);
      }
    }

    function populateSidebar() {
      // Populate class/ascendancy
      populateClassDropdown();
      const ascSelect = document.getElementById('te-asc-select') as HTMLSelectElement;
      ascSelect?.addEventListener('change', () => {
        onAscendancyChange(ascSelect.value);
      });

      if (!skillsData) {
        setInfo('Warning: Could not load skills.json. Save/load will not work.');
        return;
      }

      const loadoutSelect = document.getElementById('te-loadout-select') as HTMLSelectElement;
      if (!loadoutSelect) return;

      // Populate loadouts
      loadoutSelect.innerHTML = '';
      for (const [key, loadout] of Object.entries(skillsData.loadouts)) {
        const opt = document.createElement('option');
        opt.value = key;
        opt.textContent = loadout.name;
        loadoutSelect.appendChild(opt);
      }

      currentLoadout = loadoutSelect.value;
      populateProgressions();

      loadoutSelect.addEventListener('change', () => {
        currentLoadout = loadoutSelect.value;
        populateProgressions();
      });
    }

    function populateProgressions() {
      if (!skillsData) return;
      const progSelect = document.getElementById('te-progression-select') as HTMLSelectElement;
      if (!progSelect) return;

      const loadout = skillsData.loadouts[currentLoadout];
      if (!loadout) return;

      progSelect.innerHTML = '';
      for (const [key, prog] of Object.entries(loadout.progressions)) {
        const opt = document.createElement('option');
        opt.value = key;
        opt.textContent = prog.name;
        progSelect.appendChild(opt);
      }

      currentProgression = progSelect.value;
      progSelect.addEventListener('change', () => {
        currentProgression = progSelect.value;
      });
    }

    function setupSidebar() {
      // Load button
      document.getElementById('te-load-btn')?.addEventListener('click', () => {
        loadFromProgression();
      });

      // Copy button
      document.getElementById('te-copy-btn')?.addEventListener('click', () => {
        copyTreeDataToClipboard();
      });

      // Download button
      document.getElementById('te-download-btn')?.addEventListener('click', () => {
        downloadSkillsJson();
      });

      // Reset button (keeps class/ascendancy selection)
      document.getElementById('te-reset-btn')?.addEventListener('click', () => {
        allocatedNodes.clear();
        allocatedMasteries.clear();
        render();
        updatePointCounters();
        updateStats();
        setInfo('All nodes cleared. Class/ascendancy selection preserved.');
      });

      // View reset
      document.getElementById('te-view-reset-btn')?.addEventListener('click', () => {
        centerView();
        render();
      });
    }

    function setInfo(text: string) {
      const el = document.getElementById('te-info');
      if (el) el.textContent = text;
    }

    // ==========================================
    // SAVE / LOAD
    // ==========================================
    function buildTreeDataJson(): string {
      const data: any = {
        class: selectedAscendancy || selectedClass || 'Unknown',
        nodes: Array.from(allocatedNodes).sort(),
      };

      // Include mastery selections if any
      if (allocatedMasteries.size > 0) {
        const masteries: Record<string, number> = {};
        for (const [nid, eid] of allocatedMasteries) {
          masteries[nid] = eid;
        }
        data.masteries = masteries;
      }

      return JSON.stringify(data);
    }

    function loadFromProgression() {
      if (!skillsData) { setInfo('skills.json not loaded.'); return; }

      const loadout = skillsData.loadouts[currentLoadout];
      if (!loadout) { setInfo('Loadout not found.'); return; }

      const prog = loadout.progressions[currentProgression];
      if (!prog) { setInfo('Progression not found.'); return; }

      const raw = prog.passiveTree?.treeData;
      if (!raw) {
        setInfo(`No treeData for "${prog.name}". Start allocating!`);
        allocatedNodes.clear();
        allocatedMasteries.clear();
        render();
        updatePointCounters();
        updateStats();
        return;
      }

      try {
        const parsed = JSON.parse(raw);
        allocatedNodes.clear();
        allocatedMasteries.clear();
        if (Array.isArray(parsed.nodes)) {
          for (const id of parsed.nodes) {
            allocatedNodes.add(String(id));
          }
        }

        // Restore mastery selections
        if (parsed.masteries && typeof parsed.masteries === 'object') {
          for (const [nid, eid] of Object.entries(parsed.masteries)) {
            allocatedMasteries.set(nid, eid as number);
          }
        }

        // Try to restore class/ascendancy from saved data
        if (parsed.class) {
          // Check if it's an ascendancy name or class name
          let foundClass = '';
          let foundAsc = '';
          for (const [clsName, ascNames] of classAscendancies) {
            if (clsName === parsed.class) { foundClass = clsName; break; }
            if (ascNames.includes(parsed.class)) { foundClass = clsName; foundAsc = parsed.class; break; }
          }
          if (foundClass) {
            const classSelect = document.getElementById('te-class-select') as HTMLSelectElement;
            if (classSelect) classSelect.value = foundClass;
            selectedClass = foundClass;
            classStartNodeId = classToStartNode.get(foundClass) || '';
            // Rebuild ascendancy dropdown
            const ascSelect = document.getElementById('te-asc-select') as HTMLSelectElement;
            if (ascSelect) {
              ascSelect.innerHTML = '<option value="">(None)</option>';
              for (const name of classAscendancies.get(foundClass) || []) {
                const opt = document.createElement('option');
                opt.value = name;
                opt.textContent = name;
                ascSelect.appendChild(opt);
              }
              if (foundAsc) ascSelect.value = foundAsc;
            }
            selectedAscendancy = foundAsc;
          }
        }

        render();
        updatePointCounters();
        updateStats();
        setInfo(`Loaded ${allocatedNodes.size} nodes from "${prog.name}".`);
      } catch (e) {
        setInfo(`Error parsing treeData: ${e}`);
      }
    }

    function copyTreeDataToClipboard() {
      const json = buildTreeDataJson();
      navigator.clipboard.writeText(json).then(() => {
        setInfo(`Copied treeData JSON (${allocatedNodes.size} nodes) to clipboard.`);
      }).catch(err => {
        setInfo(`Clipboard error: ${err}`);
      });
    }

    function downloadSkillsJson() {
      if (!skillsData) { setInfo('skills.json not loaded.'); return; }

      // Deep clone the skills data
      const clone = JSON.parse(JSON.stringify(skillsData)) as SkillsJson;

      // Update the selected progression's treeData
      const loadout = clone.loadouts[currentLoadout];
      if (loadout) {
        const prog = loadout.progressions[currentProgression];
        if (prog) {
          prog.passiveTree.treeData = buildTreeDataJson();
        }
      }

      // Download
      const blob = new Blob([JSON.stringify(clone, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'skills.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      setInfo(`Downloaded skills.json with "${currentProgression}" treeData updated.`);
    }

    // ==========================================
    // VIEW CONTROLS (same as V2)
    // ==========================================
    function resizeCanvas() {
      if (!viewer || !canvas) return;
      const rect = viewer.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;
      render();
    }

    function centerView() {
      panX = 0;
      panY = 0;
      zoom = 0.05;
      if (zoomValue) zoomValue.textContent = `${Math.round(zoom * 1000)}%`;
    }

    function setupViewControls() {
      if (!viewer || !canvas) return;

      viewer.addEventListener('pointerdown', (e) => {
        // Don't capture pointer if clicking inside the mastery popup (would prevent button clicks)
        const popup = document.getElementById('te-mastery-popup');
        if (popup && popup.style.display !== 'none' && popup.contains(e.target as Node)) {
          return;
        }
        isPanning = true;
        panStartX = e.clientX - panX;
        panStartY = e.clientY - panY;
        viewer!.setPointerCapture(e.pointerId);
      });

      viewer.addEventListener('pointermove', (e) => {
        if (!isPanning) return;
        panX = e.clientX - panStartX;
        panY = e.clientY - panStartY;
        render();
      });

      viewer.addEventListener('pointerup', (e) => {
        if (isPanning) {
          viewer!.releasePointerCapture(e.pointerId);
        }
        isPanning = false;
      });

      viewer.addEventListener('pointerleave', () => {
        isPanning = false;
      });

      viewer.addEventListener('wheel', (e: WheelEvent) => {
        e.preventDefault();
        const rect = canvas!.getBoundingClientRect();
        const mouseX = e.clientX - rect.left - canvas!.width / 2 - panX;
        const mouseY = e.clientY - rect.top - canvas!.height / 2 - panY;

        const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
        const newZoom = Math.max(0.01, Math.min(0.5, zoom * zoomFactor));

        if (newZoom !== zoom) {
          const scale = newZoom / zoom;
          panX = panX - mouseX * (scale - 1);
          panY = panY - mouseY * (scale - 1);
          zoom = newZoom;
          if (zoomValue) zoomValue.textContent = `${Math.round(zoom * 1000)}%`;
          render();
        }
      }, { passive: false });

      viewer.addEventListener('contextmenu', (e) => e.preventDefault());
      window.addEventListener('resize', resizeCanvas);

      // Initial size
      resizeCanvas();
    }

    // ==========================================
    // AUTH INIT (must be after all declarations)
    // ==========================================
    authBtn?.addEventListener('click', async () => {
      const pw = authInput?.value || '';
      if (!pw) { if (authError) authError.textContent = 'Please enter a password.'; return; }
      if (await tryAuth(pw)) {
        unlock();
      } else {
        if (authError) authError.textContent = 'Incorrect password.';
        if (authInput) authInput.value = '';
      }
    });

    authInput?.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') authBtn?.click();
    });

    // Check localStorage cache
    if (localStorage.getItem(AUTH_KEY) === 'true') {
      unlock();
    }

  })();
</script>
